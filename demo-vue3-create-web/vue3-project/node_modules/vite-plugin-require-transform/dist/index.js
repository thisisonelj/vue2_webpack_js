var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => vitePluginRequireTransform
});
module.exports = __toCommonJS(src_exports);
var parser = __toESM(require("@babel/parser"));
var import_traverse = __toESM(require("@babel/traverse"));
var import_generator = __toESM(require("@babel/generator"));
var t = __toESM(require("@babel/types"));
function vitePluginRequireTransform(params = {}) {
  const { fileRegex = /.ts$|.tsx$/, importPrefix: prefix = "_vite_plugin_require_transform_", importPathHandler } = params;
  let importMap = /* @__PURE__ */ new Map();
  let variableMather = {};
  let requirePathMatcher = {};
  return {
    name: prefix,
    async transform(code, id) {
      let newCode = code;
      let sourcemap = null;
      if (fileRegex.test(id)) {
        let plugins = [];
        const ast = parser.parse(code, {
          sourceType: "module",
          plugins,
          sourceFilename: id
        });
        const declaredVariables = {};
        (0, import_traverse.default)(ast, {
          enter(path) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A;
            if (((_a = path.parentPath) == null ? void 0 : _a.node) && t.isVariableDeclarator(path.parentPath.node)) {
              const name = path.parentPath.node.id.name;
              if (!declaredVariables[name]) {
                declaredVariables[name] = path.parentPath.node;
              }
            }
            if (path.isIdentifier({ name: "require" }) && t.isCallExpression((_b = path == null ? void 0 : path.parentPath) == null ? void 0 : _b.node)) {
              const argument = path.parentPath.node.arguments[0];
              const isTemplateLiteral2 = t.isTemplateLiteral(argument);
              let templateElementValue = "";
              if (isTemplateLiteral2) {
                const tl = argument;
                for (let i = 0; i < tl.quasis.length; i++) {
                  const element = tl.quasis[i];
                  const identifier2 = tl.expressions[i];
                  const variableValue = (_e = (_d = (_c = declaredVariables[identifier2 == null ? void 0 : identifier2.name]) == null ? void 0 : _c.init) == null ? void 0 : _d.value) != null ? _e : "";
                  templateElementValue += (_f = element == null ? void 0 : element.value) == null ? void 0 : _f.raw;
                  templateElementValue += variableValue;
                }
              }
              let originalRequirePath = !isTemplateLiteral2 ? argument.value : templateElementValue;
              let requirePath = originalRequirePath;
              if (importPathHandler) {
                requirePath = importPathHandler(requirePath);
              } else {
                requirePath = requirePath.replace(/(.*\/)*([^.]+).*/ig, "$2").replace(/-/g, "_");
              }
              requirePathMatcher[requirePath] = originalRequirePath;
              if (!importMap.has(requirePath)) {
                importMap.set(requirePath, /* @__PURE__ */ new Set());
              }
              if (t.isMemberExpression(path.parentPath.parentPath) && t.isIdentifier((_i = (_h = (_g = path == null ? void 0 : path.parentPath) == null ? void 0 : _g.parentPath) == null ? void 0 : _h.node) == null ? void 0 : _i.property)) {
                const requirePathExports = importMap.get(requirePath);
                const property = (_l = (_k = (_j = path == null ? void 0 : path.parentPath) == null ? void 0 : _j.parentPath) == null ? void 0 : _k.node) == null ? void 0 : _l.property;
                const currentExport = property == null ? void 0 : property.name;
                if (requirePathExports) {
                  requirePathExports.add(currentExport);
                  importMap.set(requirePath, requirePathExports);
                  path.parentPath.parentPath.replaceWithSourceString(prefix + requirePath + "_" + currentExport);
                }
              } else {
                path.parentPath.replaceWithSourceString(prefix + requirePath);
                if (t.isVariableDeclarator((_n = (_m = path.parentPath) == null ? void 0 : _m.parentPath) == null ? void 0 : _n.node)) {
                  const variableDeclarator2 = (_p = (_o = path.parentPath) == null ? void 0 : _o.parentPath) == null ? void 0 : _p.node;
                  variableMather[variableDeclarator2.id.name] = requirePath;
                }
                if (t.isConditionalExpression((_r = (_q = path.parentPath) == null ? void 0 : _q.parentPath) == null ? void 0 : _r.node) && t.isVariableDeclarator((_u = (_t = (_s = path == null ? void 0 : path.parentPath) == null ? void 0 : _s.parentPath) == null ? void 0 : _t.parentPath) == null ? void 0 : _u.node)) {
                  const variableDeclarator2 = (_x = (_w = (_v = path.parentPath) == null ? void 0 : _v.parentPath) == null ? void 0 : _w.parentPath) == null ? void 0 : _x.node;
                  variableMather[variableDeclarator2.id.name] = requirePath;
                }
              }
            }
            const isRawMethodCheck = (currentExport) => {
              return Object.prototype.toString.call(new Array()[currentExport]).includes("Function") || Object.prototype.toString.call(new Object()[currentExport]).includes("Function");
            };
            if (t.isIdentifier(path.node) && variableMather[(_y = path.node) == null ? void 0 : _y.name]) {
              const requirePath = variableMather[path.node.name];
              const requirePathExports = importMap.get(requirePath);
              const currentExport = (_A = (_z = path.parentPath.node) == null ? void 0 : _z.property) == null ? void 0 : _A.name;
              if (currentExport && !isRawMethodCheck(currentExport) && requirePathExports)
                requirePathExports.add(currentExport);
            }
          }
        });
        for (const importItem of importMap.entries()) {
          let originalPath = requirePathMatcher[importItem[0]];
          let requireSpecifier = importItem[0];
          if (importPathHandler) {
            requireSpecifier = importPathHandler(requireSpecifier);
          } else {
            requireSpecifier = requireSpecifier.replace(/(.*\/)*([^.]+).*/ig, "$2").replace(/-/g, "_");
          }
          if (importItem[1].size) {
            const importSpecifiers = [];
            for (const item of importItem[1].values()) {
              item && importSpecifiers.push(t.importSpecifier(t.identifier(prefix + requireSpecifier + "_" + item), t.identifier(item)));
            }
            const importDeclaration2 = t.importDeclaration(importSpecifiers, t.stringLiteral(originalPath));
            ast.program.body.unshift(importDeclaration2);
          } else {
            const importDefaultSpecifier2 = [t.importDefaultSpecifier(t.identifier(prefix + requireSpecifier))];
            const importDeclaration2 = t.importDeclaration(importDefaultSpecifier2, t.stringLiteral(originalPath));
            ast.program.body.unshift(importDeclaration2);
          }
        }
        const statementList = [];
        for (const requirePath of Object.values(variableMather)) {
          const importExports = importMap.get(requirePath);
          if (importExports == null ? void 0 : importExports.size) {
            const idIdentifier = t.identifier(prefix + requirePath);
            const properties = [];
            for (const currentExport of importExports == null ? void 0 : importExports.values()) {
              properties.push(t.objectProperty(t.identifier(currentExport), t.identifier(prefix + requirePath + "_" + currentExport)));
            }
            const initObjectExpression = t.objectExpression(properties);
            statementList.push(t.variableDeclaration("const", [t.variableDeclarator(idIdentifier, initObjectExpression)]));
          }
        }
        const index = ast.program.body.findIndex((value) => {
          return !t.isImportDeclaration(value);
        });
        ast.program.body.splice(index, 0, ...statementList);
        const output = (0, import_generator.default)(ast);
        newCode = output.code;
        sourcemap = output.map;
      }
      importMap = /* @__PURE__ */ new Map();
      variableMather = {};
      return { code: newCode, map: sourcemap };
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
